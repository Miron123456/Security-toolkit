# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'metadata.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.
from security_toolkit_interface import Ui_mainWindow
from PyQt5 import QtCore, QtGui, QtWidgets
import sys
from PyQt5.QtWidgets import QApplication, QMainWindow, QFileDialog
from exif import Image
from PIL import Image as pil_Image
import string
import secrets
import os
from captcha.image import ImageCaptcha
from captcha.audio import AudioCaptcha


# pyuic5 security_toolkit.ui -o security_toolkit_interface.py


class M(QMainWindow, Ui_mainWindow):
    def __init__(self):
        super().__init__()
        self.setupUi(self)

        # Metadata remover
        self.file = None
        self.file2 = None
        self.image_name_ = None
        self.select_img.clicked.connect(self.load_file)
        self.select_img_2.clicked.connect(self.save_file)
        self.pushButton.clicked.connect(self.metadata_start)

        # Password generator
        self.generate_password_button.clicked.connect(self.generate_password_start)
        self.select_img_7.clicked.connect(self.password_select_folder)
        self.radioButton.clicked.connect(self.p_design_radio_button)
        self.radioButton_2.clicked.connect(self.p_design_radio_button_2)

        # Captcha generator
        self.create_img_captcha.clicked.connect(self.img_captcha_start)
        self.create_audio_captcha.clicked.connect(self.audio_captcha_start)
        self.captcha_folder.clicked.connect(self.captcha_select_folder)

        # Следующие строки кода нужны для того, чтобы подсвечивать разные элементы выпадающего списка разными цветами ->
        # -> в зависимости от того, является ли формат изображения свободным (open source) или проприетарным

        combo_box_elements = self.img_captcha_combo_box.model()
        # Подходят цвета в формате hex, а также "red", "green" и т.д.
        # Цвета rgb(x, x, x) не поддерживаются
        color_list = enumerate(["red", "123, 123, 200", "#ffe135"])
        for i, c in color_list:
            combo_box_elements.setData(combo_box_elements.index(i, 0), QtGui.QColor(c), QtCore.Qt.ForegroundRole)

    # Metadata remover

    def load_file(self):
        self.file = QFileDialog.getOpenFileName(self)  # Для выбора файла
        self.path_edit.setText(str(self.file[0]))

    def save_file(self):
        self.file2 = QFileDialog.getExistingDirectory(self)  # Для выбора папки
        self.path_edit_2.setText(str(self.file2))

    def metadata_start(self):
        try:
            file_path = self.path_edit.text()
            save_path = self.path_edit_2.text()
            a = pil_Image.open(self.file[0])
            a = a.convert("RGB")
            a.save("temp/1.jpg", quality=100)
            with open("temp/1.jpg", 'rb') as img_file:
                img = Image(img_file)
            if img.has_exif:
                self.textBrowser.setText("1")
            else:
                self.textBrowser.setText("2")
            print(f"{save_path}{self.file[0][self.file[0].rfind('/'):]}")
            print(img.has_exif)
            img.list_all().clear()
            print(img.has_exif)
            # Сохранение изображения в выбранную папку
            with open(f"{save_path}{self.file[0][self.file[0].rfind('/'):]}", 'wb') as new_image_file:
                new_image_file.write(img.get_file())
            os.remove("temp/1.jpg")
        except:
            self.textBrowser.clear()
            self.textBrowser.setText("Fill in the 'File' and 'Save' paths")

    # Password generator

    def p_design_radio_button(self):
        self.textBrowser_5.setDisabled(1)
        self.label_10.setEnabled(1)
        self.label_9.setEnabled(1)
        self.lineEdit.setEnabled(1)
        self.path_edit_7.setEnabled(1)
        self.select_img_7.setEnabled(1)
        self.random_name.setEnabled(1)

    # Булевое значение у setDisabled и setEnabled:
    # setD(1) отключает виджет, setD(0) включает его
    # Зачем это нужно, если есть setEnabled?..
    def p_design_radio_button_2(self):
        self.textBrowser_5.setEnabled(1)
        self.label_10.setEnabled(0)
        self.label_9.setEnabled(0)
        self.lineEdit.setEnabled(0)
        self.path_edit_7.setEnabled(0)
        self.select_img_7.setEnabled(0)
        self.random_name.setEnabled(0)

    def password_select_folder(self):
        self.p_text_file = QFileDialog.getExistingDirectory()  # Для выбора папки
        self.path_edit_7.setText(self.p_text_file)

    def generate_password_start(self):
        try:
            text = self.Password_len.text()

            # Если пользователь введет нецелое значение длины пароля
            if "," in text:
                len_ = int(text[:text.index(",")])
            else:
                len_ = int(self.Password_len.text())

            flag_list = [self.checkBox_a.isChecked(),
                         self.checkBox_b.isChecked(),
                         self.checkBox_c.isChecked(),
                         self.checkBox_d.isChecked()
                         ]

            list_ = [
                string.ascii_lowercase,
                string.ascii_uppercase,
                string.digits,
                string.punctuation
            ]

            # Для определения, какие символы входят в пароль
            password_characters = "".join(list(filter(lambda x: flag_list[list_.index(x)], list_)))
            p = "".join([secrets.choice(password_characters) for _ in range(len_)])

            if self.radioButton.isChecked():
                name = self.lineEdit.text()
                t = self.path_edit_7.text()
                text_file = open(f"{t}/{name}.txt", "w+")
                text_file.write(p)
                text_file.close()
                self.textBrowser_5.clear()
            else:
                self.textBrowser_5.setText(p)
        except:
            self.textBrowser_5.setEnabled(1)
            self.textBrowser_5.setText("Fill in all text fields and at least one check box")

    def captcha_select_folder(self):
        self.captcha_folder_path = QFileDialog.getExistingDirectory()  # Для выбора папки
        self.captcha_save_path.setText(self.captcha_folder_path)

    def captcha(self):
        self.captcha_text = str(self.captcha_text_edit.toPlainText())
        self.name = self.captcha_name.text()

    def img_captcha_start(self):
        try:
            self.captcha()
            img_captcha_1 = ImageCaptcha(width=int(self.captcha_width.text()),
                                         height=int(self.captcha_height.text()))
            # img_captcha_2 = img_captcha_1.generate(self.captcha_text)
            self.name = self.captcha_name.text()
            t = self.captcha_save_path.text()
            format = self.img_captcha_combo_box.currentText()
            img_captcha_1.write(self.captcha_text, f"{t}/{self.name}.{format}")
            self.textBrowser_3.clear()
        except:
            self.textBrowser_3.setText("Correctly fill in all text fields")

    def audio_captcha_start(self):
        try:
            self.captcha()
            audio_captcha = AudioCaptcha()
            t = self.captcha_save_path.text()
            format = self.audio_captcha_combo_box.currentText()
            audio_captcha.write(self.captcha_text, f"{t}/{self.name}.{format}")
            self.textBrowser_3.clear()
        except:
            self.textBrowser_3.setText("Correctly fill in all text fields")


if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = M()
    ex.show()
    sys.exit(app.exec_())
